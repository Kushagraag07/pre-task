name: CI/CD — Build, Push, Deploy, Test

on:
  push:
    branches:
      - main

permissions:
  contents: read
  id-token: write
  pull-requests: write

env:
  PROJECT_ID: "cme-task-476714"
  LOCATION: "us-central1"
  CLUSTER_NAME: "cme-task-476714-autopilot"
  IMAGE_REPO: "us-central1-docker.pkg.dev/cme-task-476714/my-docker-repo/test_project-2-backend"
  IMAGE_NAME: "test_project-2-backend"
  NAMESPACE: "default"
  DEPLOYMENT: "cme-task"
  CONTAINER_NAME: "backend"
  SERVICE_NAME: "cme-task-service"
  PORT: 5000

jobs:
  build-and-deploy:
    name: Build → Push → Deploy → Test
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Authenticate to GCP using Workload Identity (OIDC)
      uses: google-github-actions/auth@v1
      with:
        workload_identity_provider: "projects/810965832511/locations/global/workloadIdentityPools/github-pool/providers/github-provider"
        service_account: "github-deployer@cme-task-476714.iam.gserviceaccount.com"
        audience: "https://github.com/Kushagraag07/pre-task"

    - name: Set up gcloud CLI
      uses: google-github-actions/setup-gcloud@v1
      with:
        project_id: ${{ env.PROJECT_ID }}
        install_components: 'gke-gcloud-auth-plugin'

    - name: Configure docker to use gcloud credential helper (Artifact Registry)
      run: |
        gcloud auth configure-docker --quiet us-central1-docker.pkg.dev

    - name: Build & push Docker image to Artifact Registry
      id: build_push
      uses: docker/build-push-action@v4
      with:
        context: .
        push: true
        tags: |
          ${{ env.IMAGE_REPO }}:${{ github.sha }}
          ${{ env.IMAGE_REPO }}:latest

    - name: Get GKE credentials
      uses: google-github-actions/get-gke-credentials@v2
      with:
        cluster_name: ${{ env.CLUSTER_NAME }}
        location: ${{ env.LOCATION }}
        project_id: ${{ env.PROJECT_ID }}

    # <<< ADDED: create/update k8s secret from GitHub secret (idempotent)
    - name: Ensure API key secret exists in cluster
      env:
        NAMESPACE: ${{ env.NAMESPACE }}
      run: |
        set -euo pipefail
        echo "Creating/updating Kubernetes secret 'api-key' in namespace ${NAMESPACE} (value from GitHub secret)"
        kubectl -n "${NAMESPACE}" create secret generic api-key \
          --from-literal=API_KEY="${{ secrets.API_KEY }}" \
          --dry-run=client -o yaml | kubectl apply -f -
        echo "Secret ensured."

    # <-- Updated step: apply manifests from your folder -->
    - name: Apply Kubernetes manifests (phase2-iac/k8s-manifests)
      run: |
        MANIFEST_DIR="phase2-iac/k8s-manifests"
        echo "Applying manifests from $MANIFEST_DIR"
        if [ -d "${MANIFEST_DIR}" ]; then
          kubectl apply -f "${MANIFEST_DIR}/"
          echo "✅ Applied manifests from ${MANIFEST_DIR}"
        else
          echo "❌ Directory ${MANIFEST_DIR} not found in repo. Listing repo root for debugging:"
          ls -la
          exit 1
        fi

    # <<< ADDED: ensure the deployment references the API_KEY env var (patch only if missing)
    - name: Ensure deployment references the API_KEY env var
      env:
        NAMESPACE: ${{ env.NAMESPACE }}
        DEPLOYMENT: ${{ env.DEPLOYMENT }}
      run: |
        set -euo pipefail
        echo "Checking if deployment ${DEPLOYMENT} already has API_KEY env var..."
        EXIST=$(kubectl -n "${NAMESPACE}" get deploy "${DEPLOYMENT}" -o jsonpath='{.spec.template.spec.containers[0].env[*].name}' 2>/dev/null || true)
        if echo "$EXIST" | grep -qw "API_KEY"; then
          echo "API_KEY env already present in deployment."
        else
          echo "API_KEY env missing — patching deployment to add env from secret."
          # If env array exists append; if not, create it
          if kubectl -n "${NAMESPACE}" get deploy "${DEPLOYMENT}" -o jsonpath='{.spec.template.spec.containers[0].env}' >/dev/null 2>&1; then
            kubectl -n "${NAMESPACE}" patch deployment "${DEPLOYMENT}" --type='json' -p='[{"op":"add","path":"/spec/template/spec/containers/0/env/-","value":{"name":"API_KEY","valueFrom":{"secretKeyRef":{"name":"api-key","key":"API_KEY"}}}}]'
          else
            kubectl -n "${NAMESPACE}" patch deployment "${DEPLOYMENT}" --type='json' -p='[{"op":"add","path":"/spec/template/spec/containers/0/env","value":[{"name":"API_KEY","valueFrom":{"secretKeyRef":{"name":"api-key","key":"API_KEY"}}}]}]'
          fi
          echo "Patched deployment to include API_KEY env."
        fi
        # show env names for visibility (no secret values)
        kubectl -n "${NAMESPACE}" get deploy "${DEPLOYMENT}" -o jsonpath='{.spec.template.spec.containers[0].env[*].name}' || true

    - name: Update K8s deployment image (rolling update) with extended timeout & diagnostics
      run: |
        set -e
        NEW_IMAGE="${{ env.IMAGE_REPO }}:${{ github.sha }}"
        echo "Updating deployment ${{ env.DEPLOYMENT }} container ${{ env.CONTAINER_NAME }} -> $NEW_IMAGE"
        kubectl -n ${{ env.NAMESPACE }} set image deployment/${{ env.DEPLOYMENT }} ${{ env.CONTAINER_NAME }}=$NEW_IMAGE
        # give pods more time to become ready (10 minutes)
        if ! kubectl -n ${{ env.NAMESPACE }} rollout status deployment/${{ env.DEPLOYMENT }} --timeout=600s; then
          echo "=== Deployment describe ==="
          kubectl -n ${{ env.NAMESPACE }} describe deployment ${{ env.DEPLOYMENT }} || true
          echo "=== Pods ==="
          kubectl -n ${{ env.NAMESPACE }} get pods -l app=${{ env.DEPLOYMENT }} -o wide || true
          echo "=== Pod describe & logs ==="
          for p in $(kubectl -n ${{ env.NAMESPACE }} get pods -l app=${{ env.DEPLOYMENT }} -o name); do
            kubectl -n ${{ env.NAMESPACE }} describe $p || true
            kubectl -n ${{ env.NAMESPACE }} logs $p -c ${{ env.CONTAINER_NAME }} --tail=200 || true
          done
          exit 1
        fi

    - name: Wait a few seconds for services to stabilize
      run: sleep 8

    - name: Get service external IP (if LoadBalancer)
      id: svc
      run: |
        SVC_NAME="${{ env.SERVICE_NAME }}"
        NS="${{ env.NAMESPACE }}"
        ip=""
        for i in {1..12}; do
          ip=$(kubectl get svc $SVC_NAME -n $NS -o jsonpath='{.status.loadBalancer.ingress[0].ip}' || true)
          if [ -n "$ip" ]; then
            echo "Found external IP: $ip"
            break
          fi
          hostname=$(kubectl get svc $SVC_NAME -n $NS -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' || true)
          if [ -n "$hostname" ]; then
            echo "Found external hostname: $hostname"
            ip="$hostname"
            break
          fi
          echo "Waiting for external IP..."
          sleep 10
        done
        echo "service_ip=$ip" >> $GITHUB_OUTPUT

    - name: Post-deploy smoke tests
      run: |
        IP="${{ steps.svc.outputs.service_ip }}"
        if [ -z "$IP" ]; then
          echo "No external IP found. Using port-forward fallback..."
          kubectl -n ${{ env.NAMESPACE }} port-forward svc/${{ env.SERVICE_NAME }} 8080:${{ env.PORT }} >/tmp/portfw.out 2>&1 &
          PF_PID=$!
          sleep 5
          BASE_URL="http://127.0.0.1:8080"
        else
          BASE_URL="http://$IP:${{ env.PORT }}"
        fi

        HEALTH_URL="$BASE_URL/health"
        DB_URL="$BASE_URL/db-check"

        echo "Probing $HEALTH_URL and $DB_URL with retries..."
        for i in $(seq 1 12); do
          set +e
          curl --fail --max-time 10 "$HEALTH_URL"
          H=$?
          curl --fail --max-time 15 "$DB_URL"
          D=$?
          set -e
          if [ $H -eq 0 ] && [ $D -eq 0 ]; then
            echo "✅ Smoke tests passed."
            break
          fi
          echo "Attempt $i/12 failed (health=$H, db=$D). Waiting 10s..."
          sleep 10
        done

        if [ -n "$PF_PID" ]; then kill $PF_PID || true; fi

        # Final assertion (fail job if still bad)
        curl --fail --max-time 10 "$HEALTH_URL"
        curl --fail --max-time 15 "$DB_URL"
